---
format:
  pdf:
    documentclass: article
    fontsize: 12pt
    monofont: "Consolas"
    extra-dependencies:
      - float
  html: 
    theme: cosmo
title: Laboratório 03 - Planejamento e Análise de Experimentos (MAE0316)
date: last-modified
date-format: long
lang: pt-BR
geometry:
    - left=2cm
    - top=2cm
    - bottom=2cm
    - right=2cm
author: 
    - name: Caio M. de Almeida - 15444560
    - name: Eduardo Yukio G. Ishihara - 15449012
    - name: Gustavo S. Garone - 15458155
    - name: Ian B. Loures - 15459667
    - name: João Victor G. de Sousa - 15463912
execute:
  echo: false
  keep-ipynb: true
fig-align: center
fig-cap-location: top
fig-pos: H
tbl-pos: H
engine: knitr
---

`\vspace{-0.5cm}\noindent\rule{\textwidth}{1pt}`{=latex}

```{css}
#| echo: false
p {
  text-align: justify
}
```

```{r}
#| output: false
# Carrega pacotes
library(tidyr)
library(knitr)
library(dplyr)
library(ggplot2)
library(patchwork)
library(pander)
library(readxl)
library(vegan)
library(npmv)
library(lmPerm)
library(devtools)
library(car)
set.seed(123)
```

Neste laboratório, usaremos "$.$" como separador decimal e quatro dígitos decimais.

# Exercício 1

```{r}
#| output: false
# Carrega dados para o exercício 1
dados <- tibble(read_excel("./Besouro.xlsx"))
# Corrigir NA na posição Trat 25 -> T1
dados$Trat[25] <- "T1"
# Transforma Planta e Tratamento em fator
dados$Planta <- as.factor(dados$Planta)
dados$Trat <- as.factor(dados$Trat)
```

## Item a

A unidade experimental são as folhas, enquanto a unidade
observacional são seus quadrantes.

## Item b

Um DCA (Delineamento Completamente Aleatorizado) realiza a alocação
aleatoriamente dos tratamentos às unidades experimentais, enquanto um DABC
(Delineamento Aleatorizado em Blocos Completos) designa para cada bloco pelo
menos uma repetição de cada tratamento.

```{r}
modeloDCA <- lm(Obser ~ Trat, data = dados)
modeloDABC <- lm(Obser ~ Planta + Trat, data = dados)
```

<!-- TODO: bonitizar anova -->

```{r}
#| label: tbl-DCA-anova
#| tbl-cap: "ANOVA para o modelo DCA"
anovaDCA <- anova(modeloDCA)
kable(anovaDCA, digits = 4)
```

```{r}
#| label: tbl-DABC-anova
#| tbl-cap: "ANOVA para o modelo DABC"
anovaDABC <- anova(modeloDABC)
kable(anovaDABC, digits = 4)
```

Vemos efeito significativo dos tratamentos em ambos modelos, como indica a
@tbl-DABC-anova e a @tbl-DCA-anova. Porém, o modelo DABC efeito significativo
para o fator Planta, o que indica que o modelo DABC é mais adequado para esses
dados.

### Verificação das assunções

Primeiramente, verificaremos as assunções do modelo com blocos (DABC)

```{r}
#| label: fig-DABC-diagnostics
#| fig-cap: "Gráfico Resíduos x Ajustados para modelo DABC"
residuos <- resid(modeloDABC)
p1 <- ggplot(data = dados, aes(x = fitted(modeloDABC), y = residuos)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  labs(x = "Valores ajustados", y = "Resíduos") +
  theme_minimal()
p1
```

O gráfico de resíduos vs ajustados na @fig-DABC-diagnostics não apresenta
padrões evidentes, sugerindo homocedasticidade dos resíduos. Prosseguiremos com
o teste de Shapiro-Wilk para normalidade dos resíduos, com resultados na
@tbl-DABC-shapiro, e um QQ-plot para visualização, na @fig-QQ-DABC.

```{r}
#| label: tbl-DABC-shapiro
shapiroDABC <- shapiro.test(residuos)
pander(shapiroDABC, digits = 4)
```

```{r}
#| label: fig-QQ-DABC
#| fig-cap: "QQ-Plot dos resíduos do modelo DABC"
ggplot(data = dados, aes(sample = residuos)) +
  stat_qq() +
  stat_qq_line(color = "red") +
  labs(x = "Quantis teóricos", y = "Quantis amostrais") +
  theme_minimal()
```

Finalmente, com normalidade não rejeitada, aplicamos o teste de Bartlett para
verificar homocedasticidade, com resultados na @tbl-DABC-bartlett.

```{r}
#| label: tbl-DABC-bartlett
bartlettDABC <- bartlett.test(residuos ~ Trat, data = dados)
pander(bartlettDABC, digits = 4)
```

Deste diagnóstico, concluímos que o modelo DABC satisfaz as assunções de
normalidade e homocedasticidade dos resíduos. Dessa forma, por incluir `Planta`
no modelo, o DABC é um modelo mais completo para esses dados. Sendo assim,
poderíamos parar nossa análise por aqui, mas seguiremos com diagnóstico do
modelo DCA.

Agora, verificaremos as assunções do modelo sem blocos (DCA)

```{r}
#| label: fig-DCA-diagnostics
#| fig-cap: "Gráfico Resíduos x Ajustados para modelo DCA"
residuosDCA <- resid(modeloDCA)
p2 <- ggplot(data = dados, aes(x = fitted(modeloDCA), y = residuosDCA)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  labs(x = "Valores ajustados", y = "Resíduos") +
  theme_minimal()
p2
```

O gráfico de resíduos vs ajustados na @fig-DCA-diagnostics pode indicar
heterocedasticidade dos resíduos. Prosseguiremos com o teste de Shapiro-Wilk
para normalidade dos resíduos, com resultados na @tbl-DCA-shapiro, e um QQ-plot
para visualização, na @fig-QQ-DCA.

```{r}
#| label: tbl-DCA-shapiro
shapiroDCA <- shapiro.test(residuosDCA)
pander(shapiroDCA, digits = 4)
```

```{r}
#| label: fig-QQ-DCA
#| fig-cap: "QQ-Plot dos resíduos do modelo DCA"
ggplot(data = dados, aes(sample = residuosDCA)) +
  stat_qq() +
  stat_qq_line(color = "red") +
  labs(x = "Quantis teóricos", y = "Quantis amostrais") +
  theme_minimal()
```

O QQ-plot na @fig-QQ-DCA sugere que os resíduos podem não seguir uma
distribuição normal, além disso, o teste de Shapiro-Wilk na @tbl-DCA-shapiro
apresentou um `valor-p` bem mais baixo que do modelo DABC, indicando uma maior
evidência contra a normalidade dos resíduos. Ainda assim, não rejeitou a
normalidade ao nível de 5%.

Com desconfiança da normalidade, usaremos o teste de Levene para verificar
homocedasticidade, com resultados na @tbl-DCA-levene.

```{r}
#| label: tbl-DCA-levene
leveneDCA <- leveneTest(residuosDCA ~ Trat, data = dados)
pander(leveneDCA, digits = 4)
```

O teste de Levene na @tbl-DCA-levene não rejeita a homocedasticidade dos
resíduos. Ainda assim, o modelo DCA apresenta mais indícios de violação da
normalidaed que o modelo DABC, que também modela melhor os dados. Desta forma,
escolheríamos o modelo DABC para descrever esses dados. Por curiosidade,
verificamos também os $R^2$ ajustados dos dois modelos, na @tbl-rsquared.

```{r}
#| label: tbl-rsquared
#| tbl-cap: "R² ajustado dos modelos DCA e DABC"
rsquared <- tibble(
  Modelo = c("DCA", "DABC"),
  "R² Ajustado" = c(
    summary(modeloDCA)$adj.r.squared,
    summary(modeloDABC)$adj.r.squared
  )
)
kable(rsquared, digits = 4)
```

## Item c

Realizaremos o teste de aleatorização para um modelo DABC, considerando que as
assunções de normalidade e homocedasticidade podem foram satisfeitas.

```{r}
#| output: false
modeloDABCperm <- lmp(Obser ~ Planta + Trat, data = dados)
```

```{r}
#| label: tbl-anova-DABC-perm
#| tbl-cap: "ANOVA por permutação para o modelo DABC"
anovaDABCperm <- anova(aov(modeloDABCperm))
kable(anovaDABCperm, digits = 4)
```

De acordo com a @tbl-anova-DABC-perm, o teste de aleatorização também indica
efeito significativo dos tratamentos. O `valor-p` do fator de tratamentos do
teste de aleatorização global é $0$ (menor que $0.0001$).

# Exercício 2

Conferimos os resultados obtidos pela geração de dadaos e implementação da
aleatorização "Manual" no `R`


```{r}
#| label: tbl-rand-manual
#| tbl-cap: "Teste de aleatorização passo-a-passo"
###############################################################
## RANDOMIZATION TEST (Gary Oehlert)
## Estatística F + Comparações múltiplas (a posteriori)
## RCBD com 3 tratamentos — dados fictícios
###############################################################

### ---------------------------------------------------------
### 1. Gerar dados fictícios
### ---------------------------------------------------------

t <- 3 # tratamentos A, B, C
b <- 6 # blocos

trat <- factor(rep(LETTERS[1:t], b))
bloco <- factor(rep(1:b, each = t))

# Médias fictícias
verdades <- c(5, 7, 6.2)

# Dados simulados
y <- rnorm(t * b, mean = rep(verdades, b), sd = 0.6)

dados <- data.frame(bloco, trat, y)

## Função para obter F da ANOVA em blocos
F_stat <- function(y, trat, bloco) {
  # Soma de quadrados tratamentos
  medias_t <- tapply(y, trat, mean)
  media_geral <- mean(y)
  n_i <- table(trat)

  SS_trat <- sum(n_i * (medias_t - media_geral)^2)
  gl_trat <- length(levels(trat)) - 1
  QM_trat <- SS_trat / gl_trat

  # Soma de quadrados bloco
  medias_b <- tapply(y, bloco, mean)
  n_j <- table(bloco)
  SS_bloco <- sum(n_j * (medias_b - media_geral)^2)
  gl_bloco <- length(levels(bloco)) - 1
  QM_bloco <- SS_bloco / gl_bloco

  # Soma de quadrados residual
  SS_total <- sum((y - media_geral)^2)
  SS_res <- SS_total - SS_trat - SS_bloco
  gl_res <- length(y) - (gl_trat + gl_bloco + 1)
  QM_res <- SS_res / gl_res

  F <- QM_bloco / QM_res
  return(F)
}

F_obs <- F_stat(y, trat, bloco)
B <- 5000
F_perm <- numeric(B)

for (k in 1:B) {
  trat_perm <- unlist(tapply(trat, bloco, sample))
  F_perm[k] <- F_stat(y, trat_perm, bloco)
}

p_value_global <- mean(F_perm >= F_obs)

pares <- combn(levels(trat), 2, simplify = FALSE)

# estatística observada para cada comparação: diferença absoluta das médias
diff_obs <- sapply(pares, function(par) {
  abs(mean(y[trat == par[1]]) - mean(y[trat == par[2]]))
})
names(diff_obs) <- sapply(pares, paste, collapse = " vs ")

# randomization null distribution para cada comparação
diff_perm <- matrix(0, nrow = B, ncol = length(pares))

for (k in 1:B) {
  trat_perm <- unlist(tapply(trat, bloco, sample))
  for (j in 1:length(pares)) {
    p <- pares[[j]]
    diff_perm[k, j] <- abs(mean(y[trat_perm == p[1]]) -
      mean(y[trat_perm == p[2]]))
  }
}

# p-values individuais
p_raw <- colMeans(diff_perm >= matrix(diff_obs,
  nrow = B, ncol = length(pares),
  byrow = TRUE
))

# Correção para múltiplos testes (Holm)
p_adj <- p.adjust(p_raw, method = "holm")

# Tabela final
comparacoes <- tibble(
  Comparacao = names(diff_obs),
  Dif_observada = diff_obs,
  p_raw,
  p_ajustado_Holm = p_adj
)
kable(comparacoes, digits = 4)
```

Vamos comparar os resultados obtidos no passo-a-passo, na @tbl-rand-manual, com
os obtidos pelo pacote `lmPerm`:

```{r}
#| label: tbl-rand-lmPerm
#| tbl-cap: "Teste de aleatorização com lmPerm"
modelo_perm <- lmp(y ~ bloco + trat, data = dados)
```
